# Cursor Rules for Full-Stack Data Cleaner Application

## Project Structure
This workspace contains a unified full-stack application with:
- `/frontend` - Next.js 15 + TypeScript + Tailwind CSS frontend
- `/backend` - Node.js + Express + TypeScript + Prisma backend
- `/shared` - Shared TypeScript types and utilities

## Database Connections
- **ENTITIES_PROD**: MySQL database for entity management (organizations, people, contacts, addresses)
- **DMS_PROD**: MySQL database for deal management system (transactions, leads, reports)

## Development Guidelines

### Backend Rules
1. **Database Access**: Always use Prisma clients (`dmsPrisma`, `entitiesPrisma`) from `/backend/src/config/db.ts`
2. **API Design**: Follow RESTful conventions with proper HTTP status codes
3. **Error Handling**: Use consistent error response format with proper logging
4. **Validation**: Use Zod schemas for request validation
5. **Pagination**: Implement pagination for all list endpoints
6. **Type Safety**: Use shared types from `/shared/types/index.ts`

### Frontend Rules
1. **API Calls**: Use `axiosClient` from `/frontend/lib/axiosClient.ts` for all backend communication
2. **No Mock Data**: Always fetch real data from backend APIs
3. **Type Safety**: Use shared types from `/shared/types/index.ts`
4. **UI Components**: Use Radix UI components with Tailwind CSS
5. **State Management**: Use Zustand for global state, React Query for server state
6. **Table Views**: Use compact, efficient table components for large datasets

### Shared Types
- All common types are defined in `/shared/types/index.ts`
- Import types using: `import { Entity, ApiResponse } from '@/shared/types'`
- Keep types in sync between frontend and backend

### API Endpoints
- Base URL: `http://localhost:3005/api/v1`
- Authentication: Basic Auth or JWT tokens
- Response Format: Always use `ApiResponse<T>` wrapper

### Code Generation
When generating code:
1. **Full-Stack Features**: Generate both frontend and backend code together
2. **Type Safety**: Ensure TypeScript types are consistent across both sides
3. **Error Handling**: Include proper error handling and user feedback
4. **Performance**: Optimize for large datasets with pagination and filtering
5. **UI/UX**: Create modern, responsive interfaces with good UX

### Database Queries
- Use Prisma ORM for all database operations
- Implement proper indexing for performance
- Handle BigInt conversion for JSON serialization
- Use transactions for bulk operations

### File Organization
- Controllers: `/backend/src/controllers/`
- Routes: `/backend/src/routes/`
- Services: `/backend/src/services/`
- Types: `/shared/types/`
- Components: `/frontend/components/`
- Pages: `/frontend/app/`

### Testing
- Backend: Jest tests in `/backend/src/test/`
- Frontend: Component tests with React Testing Library
- Integration: API endpoint testing

### Environment Variables
- Backend: `/backend/.env`
- Frontend: `/frontend/.env.local`
- Shared config: `/frontend/config/env.ts`

## Common Patterns

### API Response Format
```typescript
{
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
  pagination?: PaginationMeta;
}
```

### Error Handling
```typescript
try {
  // operation
} catch (error) {
  logger.error('Operation failed', { error: error.message });
  return res.status(500).json({
    success: false,
    error: 'Internal server error',
    message: error.message
  });
}
```

### Pagination
```typescript
const { page = 1, limit = 20 } = req.query;
const offset = (page - 1) * limit;
const total = await model.count();
const data = await model.findMany({ skip: offset, take: limit });
```

### Type-Safe API Calls
```typescript
const response = await axiosClient.get<ApiResponse<Entity[]>>('/entities');
if (response.data.success) {
  // Use response.data.data with full type safety
}
```

## Performance Considerations
- Implement database indexing for frequently queried fields
- Use pagination for large datasets
- Implement caching where appropriate
- Optimize Prisma queries to avoid N+1 problems
- Use React Query for efficient data fetching and caching

## Security
- Validate all inputs using Zod schemas
- Sanitize database queries to prevent injection
- Implement proper authentication and authorization
- Use HTTPS in production
- Validate file uploads and user inputs
